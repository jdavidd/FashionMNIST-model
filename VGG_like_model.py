# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/140_llrH8gheKdPVTdu0qoPTMX8ZIfIsd
"""

import torch 
import torch.nn as nn
import torch.nn.functional as F
import torchvision.datasets as dsets
from skimage import transform
import torchvision.transforms as transforms
from torch.autograd import Variable
import pandas as pd;
import numpy as np;
from torch.utils.data import Dataset, DataLoader
#from vis_utils import *
import random;
import math;
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/gdrive/')

df_train = pd.read_csv('/content/gdrive/My Drive/FashionMnist/fashionmnist/fashion-mnist_train.csv')
df_test = pd.read_csv('/content/gdrive/My Drive/FashionMnist/fashionmnist/fashion-mnist_test.csv')

df_train = df_train.values
df_test = df_test.values

train_x = df_train[:,1:785]
train_y = df_train[:,0]

test_x = df_test[:,1:785]
test_y = df_test[:,0]

train_x = train_x.reshape((-1,28,28))
test_x = test_x.reshape((-1,28,28))

labels_map = {0 : 'T-Shirt', 1 : 'Trouser', 2 : 'Pullover', 3 : 'Dress', 4 : 'Coat', 5 : 'Sandal', 6 : 'Shirt',
              7 : 'Sneaker', 8 : 'Bag', 9 : 'Ankle Boot'};

fig = plt.figure(figsize=(8,8));
columns = 4;
rows = 5;

for i in range(1, columns*rows +1):
    img_xy = np.random.randint(len(train_x));
    img = train_x[img_xy,:]
    fig.add_subplot(rows, columns, i)
    plt.title(labels_map[train_y[img_xy]])
    plt.axis('off')
    plt.imshow(img, cmap='gray')
plt.show()

train_x = torch.from_numpy(train_x)
train_y = torch.from_numpy(train_y)
test_x = torch.from_numpy(test_x)
test_y = torch.from_numpy(test_y)

class FashionMNISTDataset(Dataset):
    '''Fashion MNIST Dataset'''
    def __init__(self, t_x, t_y, transform=None):
        self.X = t_x
        self.Y = t_y
        self.transform = transform
    def __len__(self):
        return len(self.X);
    
    def __getitem__(self, idx):
        item = self.X[idx];
        label = self.Y[idx];
        
        if self.transform:
            item = self.transform(np.float32(item));
        
        return (item, label);

#Use this for data augmentation
transform_train = transforms.Compose([
    transforms.ToPILImage(),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
])

batch_size = 100;
train_dataset = FashionMNISTDataset(train_x, train_y, transform_train)
test_dataset = FashionMNISTDataset(test_x,test_y)
train_loader = torch.utils.data.DataLoader(dataset=train_dataset,
                                           batch_size=batch_size,
                                           shuffle=True);
test_loader = torch.utils.data.DataLoader(dataset=test_dataset,
                                          batch_size=batch_size,
                                          shuffle=True);

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

# Assuming that we are on a CUDA machine, this should print a CUDA device:

print(device)

no_filters1 = 32
no_filters2 = 64
no_filters3 = 128
no_filters4 = 256

no_neurons1 = 512
class CNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, no_filters1, 3, 1, 1)
        self.conv2 =  nn.Conv2d(no_filters1, no_filters1, 3, 1, 1)
        
        self.conv3 = nn.Conv2d(no_filters1,no_filters2, 3, 1, 1)
        self.conv4 =  nn.Conv2d(no_filters2, no_filters2, 3, 1, 1)
        
        self.conv5 = nn.Conv2d(no_filters2,no_filters3, 3, 1, 1)
        self.conv6 =  nn.Conv2d(no_filters3, no_filters3, 3, 1, 1)

        self.conv7 =  nn.Conv2d(no_filters3, no_filters4, 3, 1, 1)
        self.conv8 = nn.Conv2d(no_filters4,no_filters4, 3, 1, 1)
        self.conv9 =  nn.Conv2d(no_filters4, no_filters4, 3, 1, 1)
        
        self.fc1 =  nn.Linear(1*1*no_filters4,no_neurons1)
        self.fc2 =  nn.Linear(no_neurons1,no_neurons1)
        self.fc3 =  nn.Linear(no_neurons1,10)
        
        self.drop_layer = nn.Dropout(0.5)
    def forward(self, x):
        x = x.reshape(-1,1,28,28)
        
        x = F.relu(self.conv1(x))
        x = F.relu(self.conv2(x))
        x = F.max_pool2d(x,2,2)

        x = F.relu(self.conv3(x))
        x = F.relu(self.conv4(x))
        x = F.max_pool2d(x,2,2)

        x = F.relu(self.conv5(x))
        x = F.relu(self.conv6(x))
        x = F.max_pool2d(x,2,2)

        x = F.relu(self.conv7(x))
        x = F.relu(self.conv8(x))
        x = F.relu(self.conv9(x))
        x = F.max_pool2d(x,2,2)

        x = x.view(-1,1*1*no_filters4)

        x = F.relu(self.fc1(x))
        x = self.drop_layer(x)
        x = F.relu(self.fc2(x))
        x = self.drop_layer(x)
        
        x = self.fc3(x)
        return F.log_softmax(x, dim=1)

no_filters1 = 32
no_filters2 = 64
no_neurons1 = 500
class CNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, no_filters1, 5, 1)
        self.conv2 =  nn.Conv2d(no_filters1, no_filters2, 3, 1)
        self.fc1 =  nn.Linear(5*5*no_filters2,no_neurons1)
        self.fc2 =  nn.Linear(no_neurons1,10)
    def forward(self, x):
        x = x.reshape(-1,1,28,28)
        x = F.relu(self.conv1(x))
        x = F.max_pool2d(x,2,2)
        print(x.shape)
        x = F.relu(self.conv2(x))
        x = F.max_pool2d(x,2,2)
        print(x.shape)
        x = x.view(-1,5*5*no_filters2)
        print(x.shape)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return F.log_softmax(x, dim=1)

num_epochs = 5;
batch_size = 100;
learning_rate = 0.005
cnn = CNN();
cnn.to(device)
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(cnn.parameters(), lr = learning_rate)

train_loss = []  
j = 0
for epoch in range(num_epochs):
    for i, (images, labels) in enumerate(train_loader):
        
        # Forward + Backward + Optimize
        images = images.to(device)
        labels = labels.to(device)
        optimizer.zero_grad()
        outputs = cnn(images.float())
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        train_loss.append(loss.cpu().detach().numpy())
        
        if (i+1) % 100 == 0:
            print ('Epoch : %d/%d, Iter : %d/%d,  Loss: %.4f' 
#                    %(epoch+1, num_epochs, i+1, len(train_dataset)//batch_size, train_loss[j]))
        j = j + 1

from numpy import array
t = train_loss
t = array(t)
l = t[0::120]
print(t.shape)
plt.xkcd()
plt.xlabel('Epoch #');
plt.ylabel('Loss');
plt.plot(l);
plt.show();

test_loss = []
cnn.eval()
correct = 0
total = 0
for images, labels in test_loader:
    images = Variable(images.float())
    images = images.to(device)
    labels = labels.to(device)
    outputs = cnn(images)
    _, predicted = torch.max(outputs.data, 1)
    total += labels.size(0)
    correct += (predicted == labels).sum()
    loss = criterion(outputs, labels)
    test_loss.append(loss.cpu().detach().numpy())
print(correct)
print('Test Accuracy of the model on the 10000 test images: %.4f %%' % (float(100 * correct) / float(total)))
#91,94 lr 0.001

t = test_loss
t = array(t)
l = t[0::10]
print(t.shape)
plt.xkcd()
plt.xlabel('Epoch #');
plt.ylabel('Loss');
plt.plot(l);
plt.show();